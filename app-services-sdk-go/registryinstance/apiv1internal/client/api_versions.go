/*
 * Apicurio Registry API [v2]
 *
 * Apicurio Registry is a datastore for standard event schemas and API designs. Apicurio Registry enables developers to manage and share the structure of their data using a REST interface. For example, client applications can dynamically push or pull the latest updates to or from the registry without needing to redeploy. Apicurio Registry also enables developers to create rules that govern how registry content can evolve over time. For example, this includes rules for content validation and version compatibility.  The Apicurio Registry REST API enables client applications to manage the artifacts in the registry. This API provides create, read, update, and delete operations for schema and API artifacts, rules, versions, and metadata.   The supported artifact types include: - Apache Avro schema - AsyncAPI specification - Google protocol buffers - GraphQL schema - JSON Schema - Kafka Connect schema - OpenAPI specification - Web Services Description Language - XML Schema Definition   **Important**: The Apicurio Registry REST API is available from `https://MY-REGISTRY-URL/apis/registry/v2` by default. Therefore you must prefix all API operation paths with `../apis/registry/v2` in this case. For example: `../apis/registry/v2/ids/globalIds/{globalId}`. 
 *
 * API version: 2.4.x
 * Contact: apicurio@lists.jboss.org
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package registryinstanceclient

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
	"os"
)

// Linger please
var (
	_ _context.Context
)

type VersionsApi interface {

	/*
	 * AddArtifactVersionComment Add new comment
	 * Adds a new comment to the artifact version.  Both the `artifactId` and the
unique `version` number must be provided.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
	 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
	 * @param version The unique identifier of a specific version of the artifact content.
	 * @return ApiAddArtifactVersionCommentRequest
	 */
	AddArtifactVersionComment(ctx _context.Context, groupId string, artifactId string, version string) ApiAddArtifactVersionCommentRequest

	/*
	 * AddArtifactVersionCommentExecute executes the request
	 * @return Comment
	 */
	AddArtifactVersionCommentExecute(r ApiAddArtifactVersionCommentRequest) (Comment, *_nethttp.Response, error)

	/*
	 * CreateArtifactVersion Create artifact version
	 * Creates a new version of the artifact by uploading new content.  The configured rules for
the artifact are applied, and if they all pass, the new content is added as the most recent 
version of the artifact.  If any of the rules fail, an error is returned.

The body of the request can be the raw content of the new artifact version, or the raw content 
and a set of references pointing to other artifacts, and the type
of that content should match the artifact's type (for example if the artifact type is `AVRO`
then the content of the request should be an Apache Avro document).

This operation can fail for the following reasons:

* Provided content (request body) was empty (HTTP error `400`)
* No artifact with this `artifactId` exists (HTTP error `404`)
* The new content violates one of the rules configured for the artifact (HTTP error `409`)
* A server error occurred (HTTP error `500`)

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
	 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
	 * @return ApiCreateArtifactVersionRequest
	 */
	CreateArtifactVersion(ctx _context.Context, groupId string, artifactId string) ApiCreateArtifactVersionRequest

	/*
	 * CreateArtifactVersionExecute executes the request
	 * @return VersionMetaData
	 */
	CreateArtifactVersionExecute(r ApiCreateArtifactVersionRequest) (VersionMetaData, *_nethttp.Response, error)

	/*
	 * DeleteArtifactVersion Delete artifact version
	 * Deletes a single version of the artifact. Parameters `groupId`, `artifactId` and the unique `version`
are needed. If this is the only version of the artifact, this operation is the same as 
deleting the entire artifact.

This feature is disabled by default and it's discouraged for normal usage. To enable it, set the `registry.rest.artifact.deletion.enabled` property to true. This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
 * Feature is disabled (HTTP error `405`)
 * A server error occurred (HTTP error `500`)

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
	 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
	 * @param version The unique identifier of a specific version of the artifact content.
	 * @return ApiDeleteArtifactVersionRequest
	 */
	DeleteArtifactVersion(ctx _context.Context, groupId string, artifactId string, version string) ApiDeleteArtifactVersionRequest

	/*
	 * DeleteArtifactVersionExecute executes the request
	 */
	DeleteArtifactVersionExecute(r ApiDeleteArtifactVersionRequest) (*_nethttp.Response, error)

	/*
	 * DeleteArtifactVersionComment Delete a single comment
	 * Deletes a single comment in an artifact version.  Only the owner of the
comment can delete it.  The `artifactId`, unique `version` number, and `commentId` 
must be provided.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* No comment with this `commentId` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
	 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
	 * @param version The unique identifier of a specific version of the artifact content.
	 * @param commentId The unique identifier of a single comment.
	 * @return ApiDeleteArtifactVersionCommentRequest
	 */
	DeleteArtifactVersionComment(ctx _context.Context, groupId string, artifactId string, version string, commentId string) ApiDeleteArtifactVersionCommentRequest

	/*
	 * DeleteArtifactVersionCommentExecute executes the request
	 */
	DeleteArtifactVersionCommentExecute(r ApiDeleteArtifactVersionCommentRequest) (*_nethttp.Response, error)

	/*
	 * GetArtifactVersion Get artifact version
	 * Retrieves a single version of the artifact content.  Both the `artifactId` and the
unique `version` number must be provided.  The `Content-Type` of the response depends 
on the artifact type.  In most cases, this is `application/json`, but for some types 
it may be different (for example, `PROTOBUF`).

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
	 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
	 * @param version The unique identifier of a specific version of the artifact content.
	 * @return ApiGetArtifactVersionRequest
	 */
	GetArtifactVersion(ctx _context.Context, groupId string, artifactId string, version string) ApiGetArtifactVersionRequest

	/*
	 * GetArtifactVersionExecute executes the request
	 * @return *os.File
	 */
	GetArtifactVersionExecute(r ApiGetArtifactVersionRequest) (*os.File, *_nethttp.Response, error)

	/*
	 * GetArtifactVersionComments Get artifact version comments
	 * Retrieves all comments for a version of an artifact.  Both the `artifactId` and the
unique `version` number must be provided.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
	 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
	 * @param version The unique identifier of a specific version of the artifact content.
	 * @return ApiGetArtifactVersionCommentsRequest
	 */
	GetArtifactVersionComments(ctx _context.Context, groupId string, artifactId string, version string) ApiGetArtifactVersionCommentsRequest

	/*
	 * GetArtifactVersionCommentsExecute executes the request
	 * @return []Comment
	 */
	GetArtifactVersionCommentsExecute(r ApiGetArtifactVersionCommentsRequest) ([]Comment, *_nethttp.Response, error)

	/*
	 * GetArtifactVersionReferences Get artifact version references
	 * Retrieves all references for a single version of an artifact.  Both the `artifactId` and the
unique `version` number must be provided.  Using the `refType` query parameter, it is possible
to retrieve an array of either the inbound or outbound references.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
	 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
	 * @param version The unique identifier of a specific version of the artifact content.
	 * @return ApiGetArtifactVersionReferencesRequest
	 */
	GetArtifactVersionReferences(ctx _context.Context, groupId string, artifactId string, version string) ApiGetArtifactVersionReferencesRequest

	/*
	 * GetArtifactVersionReferencesExecute executes the request
	 * @return []ArtifactReference
	 */
	GetArtifactVersionReferencesExecute(r ApiGetArtifactVersionReferencesRequest) ([]ArtifactReference, *_nethttp.Response, error)

	/*
	 * ListArtifactVersions List artifact versions
	 * Returns a list of all versions of the artifact.  The result set is paged.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
	 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
	 * @return ApiListArtifactVersionsRequest
	 */
	ListArtifactVersions(ctx _context.Context, groupId string, artifactId string) ApiListArtifactVersionsRequest

	/*
	 * ListArtifactVersionsExecute executes the request
	 * @return VersionSearchResults
	 */
	ListArtifactVersionsExecute(r ApiListArtifactVersionsRequest) (VersionSearchResults, *_nethttp.Response, error)

	/*
	 * UpdateArtifactVersionComment Update a comment
	 * Updates the value of a single comment in an artifact version.  Only the owner of the
comment can modify it.  The `artifactId`, unique `version` number, and `commentId` 
must be provided.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* No comment with this `commentId` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
	 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
	 * @param version The unique identifier of a specific version of the artifact content.
	 * @param commentId The unique identifier of a single comment.
	 * @return ApiUpdateArtifactVersionCommentRequest
	 */
	UpdateArtifactVersionComment(ctx _context.Context, groupId string, artifactId string, version string, commentId string) ApiUpdateArtifactVersionCommentRequest

	/*
	 * UpdateArtifactVersionCommentExecute executes the request
	 */
	UpdateArtifactVersionCommentExecute(r ApiUpdateArtifactVersionCommentRequest) (*_nethttp.Response, error)

	/*
	 * UpdateArtifactVersionState Update artifact version state
	 * Updates the state of a specific version of an artifact.  For example, you can use 
this operation to disable a specific version.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

	 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
	 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
	 * @param version The unique identifier of a specific version of the artifact content.
	 * @return ApiUpdateArtifactVersionStateRequest
	 */
	UpdateArtifactVersionState(ctx _context.Context, groupId string, artifactId string, version string) ApiUpdateArtifactVersionStateRequest

	/*
	 * UpdateArtifactVersionStateExecute executes the request
	 */
	UpdateArtifactVersionStateExecute(r ApiUpdateArtifactVersionStateRequest) (*_nethttp.Response, error)
}

// VersionsApiService VersionsApi service
type VersionsApiService service

type ApiAddArtifactVersionCommentRequest struct {
	ctx _context.Context
	ApiService VersionsApi
	groupId string
	artifactId string
	version string
	newComment *NewComment
}

func (r ApiAddArtifactVersionCommentRequest) NewComment(newComment NewComment) ApiAddArtifactVersionCommentRequest {
	r.newComment = &newComment
	return r
}

func (r ApiAddArtifactVersionCommentRequest) Execute() (Comment, *_nethttp.Response, error) {
	return r.ApiService.AddArtifactVersionCommentExecute(r)
}

/*
 * AddArtifactVersionComment Add new comment
 * Adds a new comment to the artifact version.  Both the `artifactId` and the
unique `version` number must be provided.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @param version The unique identifier of a specific version of the artifact content.
 * @return ApiAddArtifactVersionCommentRequest
 */
func (a *VersionsApiService) AddArtifactVersionComment(ctx _context.Context, groupId string, artifactId string, version string) ApiAddArtifactVersionCommentRequest {
	return ApiAddArtifactVersionCommentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		artifactId: artifactId,
		version: version,
	}
}

/*
 * Execute executes the request
 * @return Comment
 */
func (a *VersionsApiService) AddArtifactVersionCommentExecute(r ApiAddArtifactVersionCommentRequest) (Comment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Comment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionsApiService.AddArtifactVersionComment")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/artifacts/{artifactId}/versions/{version}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.newComment == nil {
		return localVarReturnValue, nil, reportError("newComment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newComment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateArtifactVersionRequest struct {
	ctx _context.Context
	ApiService VersionsApi
	groupId string
	artifactId string
	body **os.File
	xRegistryVersion *string
	xRegistryName *string
	xRegistryDescription *string
	xRegistryDescriptionEncoded *string
	xRegistryNameEncoded *string
	contentType *string
}

func (r ApiCreateArtifactVersionRequest) Body(body *os.File) ApiCreateArtifactVersionRequest {
	r.body = &body
	return r
}
func (r ApiCreateArtifactVersionRequest) XRegistryVersion(xRegistryVersion string) ApiCreateArtifactVersionRequest {
	r.xRegistryVersion = &xRegistryVersion
	return r
}
func (r ApiCreateArtifactVersionRequest) XRegistryName(xRegistryName string) ApiCreateArtifactVersionRequest {
	r.xRegistryName = &xRegistryName
	return r
}
func (r ApiCreateArtifactVersionRequest) XRegistryDescription(xRegistryDescription string) ApiCreateArtifactVersionRequest {
	r.xRegistryDescription = &xRegistryDescription
	return r
}
func (r ApiCreateArtifactVersionRequest) XRegistryDescriptionEncoded(xRegistryDescriptionEncoded string) ApiCreateArtifactVersionRequest {
	r.xRegistryDescriptionEncoded = &xRegistryDescriptionEncoded
	return r
}
func (r ApiCreateArtifactVersionRequest) XRegistryNameEncoded(xRegistryNameEncoded string) ApiCreateArtifactVersionRequest {
	r.xRegistryNameEncoded = &xRegistryNameEncoded
	return r
}
func (r ApiCreateArtifactVersionRequest) ContentType(contentType string) ApiCreateArtifactVersionRequest {
	r.contentType = &contentType
	return r
}

func (r ApiCreateArtifactVersionRequest) Execute() (VersionMetaData, *_nethttp.Response, error) {
	return r.ApiService.CreateArtifactVersionExecute(r)
}

/*
 * CreateArtifactVersion Create artifact version
 * Creates a new version of the artifact by uploading new content.  The configured rules for
the artifact are applied, and if they all pass, the new content is added as the most recent 
version of the artifact.  If any of the rules fail, an error is returned.

The body of the request can be the raw content of the new artifact version, or the raw content 
and a set of references pointing to other artifacts, and the type
of that content should match the artifact's type (for example if the artifact type is `AVRO`
then the content of the request should be an Apache Avro document).

This operation can fail for the following reasons:

* Provided content (request body) was empty (HTTP error `400`)
* No artifact with this `artifactId` exists (HTTP error `404`)
* The new content violates one of the rules configured for the artifact (HTTP error `409`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @return ApiCreateArtifactVersionRequest
 */
func (a *VersionsApiService) CreateArtifactVersion(ctx _context.Context, groupId string, artifactId string) ApiCreateArtifactVersionRequest {
	return ApiCreateArtifactVersionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		artifactId: artifactId,
	}
}

/*
 * Execute executes the request
 * @return VersionMetaData
 */
func (a *VersionsApiService) CreateArtifactVersionExecute(r ApiCreateArtifactVersionRequest) (VersionMetaData, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VersionMetaData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionsApiService.CreateArtifactVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/artifacts/{artifactId}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.body == nil {
		return localVarReturnValue, nil, reportError("body is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/vnd.json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.xRegistryVersion != nil {
		localVarHeaderParams["X-Registry-Version"] = parameterToString(*r.xRegistryVersion, "")
	}
	if r.xRegistryName != nil {
		localVarHeaderParams["X-Registry-Name"] = parameterToString(*r.xRegistryName, "")
	}
	if r.xRegistryDescription != nil {
		localVarHeaderParams["X-Registry-Description"] = parameterToString(*r.xRegistryDescription, "")
	}
	if r.xRegistryDescriptionEncoded != nil {
		localVarHeaderParams["X-Registry-Description-Encoded"] = parameterToString(*r.xRegistryDescriptionEncoded, "")
	}
	if r.xRegistryNameEncoded != nil {
		localVarHeaderParams["X-Registry-Name-Encoded"] = parameterToString(*r.xRegistryNameEncoded, "")
	}
	if r.contentType != nil {
		localVarHeaderParams["Content-Type"] = parameterToString(*r.contentType, "")
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 409 {
			var v RuleViolationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteArtifactVersionRequest struct {
	ctx _context.Context
	ApiService VersionsApi
	groupId string
	artifactId string
	version string
}


func (r ApiDeleteArtifactVersionRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteArtifactVersionExecute(r)
}

/*
 * DeleteArtifactVersion Delete artifact version
 * Deletes a single version of the artifact. Parameters `groupId`, `artifactId` and the unique `version`
are needed. If this is the only version of the artifact, this operation is the same as 
deleting the entire artifact.

This feature is disabled by default and it's discouraged for normal usage. To enable it, set the `registry.rest.artifact.deletion.enabled` property to true. This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
 * Feature is disabled (HTTP error `405`)
 * A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @param version The unique identifier of a specific version of the artifact content.
 * @return ApiDeleteArtifactVersionRequest
 */
func (a *VersionsApiService) DeleteArtifactVersion(ctx _context.Context, groupId string, artifactId string, version string) ApiDeleteArtifactVersionRequest {
	return ApiDeleteArtifactVersionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		artifactId: artifactId,
		version: version,
	}
}

/*
 * Execute executes the request
 */
func (a *VersionsApiService) DeleteArtifactVersionExecute(r ApiDeleteArtifactVersionRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionsApiService.DeleteArtifactVersion")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/artifacts/{artifactId}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteArtifactVersionCommentRequest struct {
	ctx _context.Context
	ApiService VersionsApi
	groupId string
	artifactId string
	version string
	commentId string
}


func (r ApiDeleteArtifactVersionCommentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.DeleteArtifactVersionCommentExecute(r)
}

/*
 * DeleteArtifactVersionComment Delete a single comment
 * Deletes a single comment in an artifact version.  Only the owner of the
comment can delete it.  The `artifactId`, unique `version` number, and `commentId` 
must be provided.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* No comment with this `commentId` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @param version The unique identifier of a specific version of the artifact content.
 * @param commentId The unique identifier of a single comment.
 * @return ApiDeleteArtifactVersionCommentRequest
 */
func (a *VersionsApiService) DeleteArtifactVersionComment(ctx _context.Context, groupId string, artifactId string, version string, commentId string) ApiDeleteArtifactVersionCommentRequest {
	return ApiDeleteArtifactVersionCommentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		artifactId: artifactId,
		version: version,
		commentId: commentId,
	}
}

/*
 * Execute executes the request
 */
func (a *VersionsApiService) DeleteArtifactVersionCommentExecute(r ApiDeleteArtifactVersionCommentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodDelete
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionsApiService.DeleteArtifactVersionComment")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/artifacts/{artifactId}/versions/{version}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", _neturl.PathEscape(parameterToString(r.commentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetArtifactVersionRequest struct {
	ctx _context.Context
	ApiService VersionsApi
	groupId string
	artifactId string
	version string
	references *HandleReferencesType
}

func (r ApiGetArtifactVersionRequest) References(references HandleReferencesType) ApiGetArtifactVersionRequest {
	r.references = &references
	return r
}

func (r ApiGetArtifactVersionRequest) Execute() (*os.File, *_nethttp.Response, error) {
	return r.ApiService.GetArtifactVersionExecute(r)
}

/*
 * GetArtifactVersion Get artifact version
 * Retrieves a single version of the artifact content.  Both the `artifactId` and the
unique `version` number must be provided.  The `Content-Type` of the response depends 
on the artifact type.  In most cases, this is `application/json`, but for some types 
it may be different (for example, `PROTOBUF`).

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @param version The unique identifier of a specific version of the artifact content.
 * @return ApiGetArtifactVersionRequest
 */
func (a *VersionsApiService) GetArtifactVersion(ctx _context.Context, groupId string, artifactId string, version string) ApiGetArtifactVersionRequest {
	return ApiGetArtifactVersionRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		artifactId: artifactId,
		version: version,
	}
}

/*
 * Execute executes the request
 * @return *os.File
 */
func (a *VersionsApiService) GetArtifactVersionExecute(r ApiGetArtifactVersionRequest) (*os.File, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionsApiService.GetArtifactVersion")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/artifacts/{artifactId}/versions/{version}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.references != nil {
		localVarQueryParams.Add("references", parameterToString(*r.references, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArtifactVersionCommentsRequest struct {
	ctx _context.Context
	ApiService VersionsApi
	groupId string
	artifactId string
	version string
}


func (r ApiGetArtifactVersionCommentsRequest) Execute() ([]Comment, *_nethttp.Response, error) {
	return r.ApiService.GetArtifactVersionCommentsExecute(r)
}

/*
 * GetArtifactVersionComments Get artifact version comments
 * Retrieves all comments for a version of an artifact.  Both the `artifactId` and the
unique `version` number must be provided.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @param version The unique identifier of a specific version of the artifact content.
 * @return ApiGetArtifactVersionCommentsRequest
 */
func (a *VersionsApiService) GetArtifactVersionComments(ctx _context.Context, groupId string, artifactId string, version string) ApiGetArtifactVersionCommentsRequest {
	return ApiGetArtifactVersionCommentsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		artifactId: artifactId,
		version: version,
	}
}

/*
 * Execute executes the request
 * @return []Comment
 */
func (a *VersionsApiService) GetArtifactVersionCommentsExecute(r ApiGetArtifactVersionCommentsRequest) ([]Comment, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []Comment
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionsApiService.GetArtifactVersionComments")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/artifacts/{artifactId}/versions/{version}/comments"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetArtifactVersionReferencesRequest struct {
	ctx _context.Context
	ApiService VersionsApi
	groupId string
	artifactId string
	version string
	refType *ReferenceType
}

func (r ApiGetArtifactVersionReferencesRequest) RefType(refType ReferenceType) ApiGetArtifactVersionReferencesRequest {
	r.refType = &refType
	return r
}

func (r ApiGetArtifactVersionReferencesRequest) Execute() ([]ArtifactReference, *_nethttp.Response, error) {
	return r.ApiService.GetArtifactVersionReferencesExecute(r)
}

/*
 * GetArtifactVersionReferences Get artifact version references
 * Retrieves all references for a single version of an artifact.  Both the `artifactId` and the
unique `version` number must be provided.  Using the `refType` query parameter, it is possible
to retrieve an array of either the inbound or outbound references.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @param version The unique identifier of a specific version of the artifact content.
 * @return ApiGetArtifactVersionReferencesRequest
 */
func (a *VersionsApiService) GetArtifactVersionReferences(ctx _context.Context, groupId string, artifactId string, version string) ApiGetArtifactVersionReferencesRequest {
	return ApiGetArtifactVersionReferencesRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		artifactId: artifactId,
		version: version,
	}
}

/*
 * Execute executes the request
 * @return []ArtifactReference
 */
func (a *VersionsApiService) GetArtifactVersionReferencesExecute(r ApiGetArtifactVersionReferencesRequest) ([]ArtifactReference, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  []ArtifactReference
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionsApiService.GetArtifactVersionReferences")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/artifacts/{artifactId}/versions/{version}/references"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.refType != nil {
		localVarQueryParams.Add("refType", parameterToString(*r.refType, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListArtifactVersionsRequest struct {
	ctx _context.Context
	ApiService VersionsApi
	groupId string
	artifactId string
	offset *int32
	limit *int32
}

func (r ApiListArtifactVersionsRequest) Offset(offset int32) ApiListArtifactVersionsRequest {
	r.offset = &offset
	return r
}
func (r ApiListArtifactVersionsRequest) Limit(limit int32) ApiListArtifactVersionsRequest {
	r.limit = &limit
	return r
}

func (r ApiListArtifactVersionsRequest) Execute() (VersionSearchResults, *_nethttp.Response, error) {
	return r.ApiService.ListArtifactVersionsExecute(r)
}

/*
 * ListArtifactVersions List artifact versions
 * Returns a list of all versions of the artifact.  The result set is paged.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @return ApiListArtifactVersionsRequest
 */
func (a *VersionsApiService) ListArtifactVersions(ctx _context.Context, groupId string, artifactId string) ApiListArtifactVersionsRequest {
	return ApiListArtifactVersionsRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		artifactId: artifactId,
	}
}

/*
 * Execute executes the request
 * @return VersionSearchResults
 */
func (a *VersionsApiService) ListArtifactVersionsExecute(r ApiListArtifactVersionsRequest) (VersionSearchResults, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  VersionSearchResults
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionsApiService.ListArtifactVersions")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/artifacts/{artifactId}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateArtifactVersionCommentRequest struct {
	ctx _context.Context
	ApiService VersionsApi
	groupId string
	artifactId string
	version string
	commentId string
	newComment *NewComment
}

func (r ApiUpdateArtifactVersionCommentRequest) NewComment(newComment NewComment) ApiUpdateArtifactVersionCommentRequest {
	r.newComment = &newComment
	return r
}

func (r ApiUpdateArtifactVersionCommentRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateArtifactVersionCommentExecute(r)
}

/*
 * UpdateArtifactVersionComment Update a comment
 * Updates the value of a single comment in an artifact version.  Only the owner of the
comment can modify it.  The `artifactId`, unique `version` number, and `commentId` 
must be provided.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* No comment with this `commentId` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @param version The unique identifier of a specific version of the artifact content.
 * @param commentId The unique identifier of a single comment.
 * @return ApiUpdateArtifactVersionCommentRequest
 */
func (a *VersionsApiService) UpdateArtifactVersionComment(ctx _context.Context, groupId string, artifactId string, version string, commentId string) ApiUpdateArtifactVersionCommentRequest {
	return ApiUpdateArtifactVersionCommentRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		artifactId: artifactId,
		version: version,
		commentId: commentId,
	}
}

/*
 * Execute executes the request
 */
func (a *VersionsApiService) UpdateArtifactVersionCommentExecute(r ApiUpdateArtifactVersionCommentRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionsApiService.UpdateArtifactVersionComment")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/artifacts/{artifactId}/versions/{version}/comments/{commentId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"commentId"+"}", _neturl.PathEscape(parameterToString(r.commentId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.newComment == nil {
		return nil, reportError("newComment is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newComment
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateArtifactVersionStateRequest struct {
	ctx _context.Context
	ApiService VersionsApi
	groupId string
	artifactId string
	version string
	updateState *UpdateState
}

func (r ApiUpdateArtifactVersionStateRequest) UpdateState(updateState UpdateState) ApiUpdateArtifactVersionStateRequest {
	r.updateState = &updateState
	return r
}

func (r ApiUpdateArtifactVersionStateRequest) Execute() (*_nethttp.Response, error) {
	return r.ApiService.UpdateArtifactVersionStateExecute(r)
}

/*
 * UpdateArtifactVersionState Update artifact version state
 * Updates the state of a specific version of an artifact.  For example, you can use 
this operation to disable a specific version.

This operation can fail for the following reasons:

* No artifact with this `artifactId` exists (HTTP error `404`)
* No version with this `version` exists (HTTP error `404`)
* A server error occurred (HTTP error `500`)

 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param groupId The artifact group ID.  Must be a string provided by the client, representing the name of the grouping of artifacts.
 * @param artifactId The artifact ID.  Can be a string (client-provided) or UUID (server-generated), representing the unique artifact identifier.
 * @param version The unique identifier of a specific version of the artifact content.
 * @return ApiUpdateArtifactVersionStateRequest
 */
func (a *VersionsApiService) UpdateArtifactVersionState(ctx _context.Context, groupId string, artifactId string, version string) ApiUpdateArtifactVersionStateRequest {
	return ApiUpdateArtifactVersionStateRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
		artifactId: artifactId,
		version: version,
	}
}

/*
 * Execute executes the request
 */
func (a *VersionsApiService) UpdateArtifactVersionStateExecute(r ApiUpdateArtifactVersionStateRequest) (*_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPut
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VersionsApiService.UpdateArtifactVersionState")
	if err != nil {
		return nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/groups/{groupId}/artifacts/{artifactId}/versions/{version}/state"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", _neturl.PathEscape(parameterToString(r.groupId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"artifactId"+"}", _neturl.PathEscape(parameterToString(r.artifactId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version"+"}", _neturl.PathEscape(parameterToString(r.version, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.updateState == nil {
		return nil, reportError("updateState is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateState
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
